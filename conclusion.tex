
\chapter{Conclusion}

This thesis set out to address a fundamental and persistent challenge in computer science: the concise and intuitive formal modelling of complex systems. While Deterministic Finite Automata (DFAs) provide the theoretical bedrock for specifying and verifying regular properties, their practical application is often hampered by the state explosion problem. For specifications that are pattern-intensive or inherently concurrent, the number of states required in a classical DFA can become unmanageably large, rendering the resulting models difficult to create, comprehend, and analyze. Existing extensions to DFAs, such as symbolic or generalized automata \cite{DBLP:conf/popl/VeanesHLMB12, giammarresi1999deterministic}, offer partial solutions by tackling alphabet size or fixed-sequence matching, but they fall short in scenarios where system behaviour is predicated on sparsely distributed patterns separated by irrelevant sequences of events. There has remained a clear need for a deterministic automaton model that can natively handle such high-level, suffix-based patterns and concurrency while retaining formal rigour and understandability.

The research presented in this thesis introduces and develops a new automaton paradigm (suffix-reading) to fill this gap. We began by formalizing the \textbf{Deterministic Suffix-reading Automaton (DSA)} \cite{Keerthan2024journal}, a model that enriches classical automata with the ability to trigger transitions based on suffixes of the input word read so far. This work has established the theoretical foundations of this model, extended it to the crucial domain of concurrent systems with the \textbf{Multi-port DSA (mDSA)} \cite{Keerthan2025netys}, and demonstrated its practical utility by providing the first formal semantics for an industrial specification language (EDT). In doing so, this research offers a novel perspective on automata theory and its application, bridging the gap between high-level system requirements and executable formal models.

\subsection*{Summary of Contributions}

The contributions of this thesis are twofold, corresponding to the theoretical investigation of the single-stream DSA model and its extension and application to concurrent systems.

\subsubsection*{1. Deterministic Suffix-reading Automata: Modelling Pattern-Intensive Specification}

The first major contribution of this work was the introduction, formalization, and analysis of the Deterministic Suffix-reading Automaton. Unlike traditional automata that process input letter-by-letter, a DSA operates on a "wait-and-jump" principle. It can remain in a state, passively consuming input, until a sequence of symbols matching a transition’s label appears as a suffix of the word seen so far. This capability is particularly powerful for "pattern-intensive" languages, where key events are interspersed with arbitrary, "don't care" sequences.

We formally proved that DSAs recognize exactly the class of regular languages, ensuring they are grounded in classical automata theory. Their value lies not in greater expressive power, but in succinctness. We established that for certain families of languages, DSAs can be exponentially more concise than their minimal DFA equivalents \cite[Lemma 2]{Keerthan2024journal}. To facilitate meaningful comparison, we defined the \textbf{total size} of a DSA as the sum of its states, edges, and the lengths of its word-based labels, a more faithful measure of complexity than state count alone \cite[Definition 1]{Keerthan2024journal}.

A significant technical contribution was the development of a \textbf{DFA-to-DSA derivation procedure} \cite[Section 5]{Keerthan2024journal}. This constructive algorithm provides a systematic method for obtaining a language-equivalent DSA from a given DFA by identifying and "suppressing" intermediate states. We identified sufficient conditions for this conversion to be correct, formalizing them through the idea of \textbf{suffix-tracking sets}, via \textbf{suffix-compatible transitions}, and \textbf{well-formed sets} \cite[Definitions 8, 9, 10]{Keerthan2024journal}. These conditions ensure that collapsing a path of DFA transitions into a single, suffix-reading DSA transition preserves the original language \cite[Theorem 2]{Keerthan2024journal}.

The investigation into finding a \textit{minimal} DSA for a given language yielded several important results. We demonstrated that, unlike for DFAs, a minimal DSA is not necessarily unique \cite[Lemma 9]{Keerthan2024journal}. More surprising was the discovery that starting our derivation procedure from the canonical (minimal) DFA of a language does not guarantee a minimal DSA. In some cases, a smaller DSA can be derived from a larger, non-minimal DFA \cite[Section 6, Figures 13, 14]{Keerthan2024journal}. This insight reveals a fundamental complexity in DSA minimization: the optimal structure for a suffix-reading model may be obscured by the structure of a minimal letter-by-letter model. Building on this, we proved that the problem of deciding if a given language has a DSA of total size less than or equal to a given bound \textit{k} is \textbf{NP-complete} \cite[Theorem 5]{Keerthan2024journal}. This hardness result underscores the challenge of optimal DSA synthesis and justifies the use of non-canonical methods, such as our derivation procedure, for practical applications.

In response to these complexity challenges, we defined a restricted subclass, \textbf{Strongly Deterministic Suffix-reading Automata (sDSAs)}, which imposes a syntactic constraint on outgoing labels to prevent prefix-suffix ambiguities \cite[Definition 14]{Keerthan2024journal}. For this class, we proved a positive result: every minimal sDSA \textit{can} be derived from the canonical DFA \cite[Theorem 4]{Keerthan2024journal}. This finding delineates a tractable subset of DSAs for which minimization is more straightforward and provides a path towards avoiding the complexity of the general case.

\subsubsection*{2. Multi-port DSA: Handling Concurrency and Enabling Practical Application}

The second part of this thesis extended the suffix-reading paradigm to concurrent systems, which represent a major source of state explosion for classical models. We introduced the \textbf{Multi-port Deterministic Suffix-reading Automaton (mDSA)}, a model where the alphabet is partitioned across multiple ports, and transitions are triggered by a conjunction of suffix patterns occurring across these independent streams \cite[Definition 2]{Keerthan2025netys}. A transition labeled \(u_1 \Vert u_2\), for instance, fires only when a suffix matching \(u_1\) has been observed on port 1 and a suffix matching \(u_2\) has been observed on port 2 (in any order across the ports).

A key challenge was defining a coherent operational semantics. A naive approach of simply consuming matched prefixes was shown to be inadequate for specifications where past events on one port must remain context for future events on another \cite[Section 3.1]{Keerthan2025netys}. Our solution was to equip the mDSA with a memory of the input history on a tape, along with a marker \(\theta\), indicating the position of the last transition match \cite[Section 3.2]{Keerthan2025netys}. A new transition can fire only if at least one of its component patterns appears entirely after this marker, resolving the ambiguity between needing "fresh" events versus persistent context \cite[Definition 3]{Keerthan2025netys}.

To model modern reactive systems, we further extended the model to \textbf{mDSAs-with-outputs}, allowing transitions to atomically write values to ports upon firing \cite[Section 4]{Keerthan2025netys}. This feature, where outputs can immediately influence the conditions for subsequent transitions, makes the model more powerful but also computationally more complex. We demonstrated that these automata are powerful enough to succinctly encode an N-bit counter, where the length of the execution trace grows exponentially with the size of the automaton \cite[Section 4.1]{Keerthan2025netys}. This led to our second major complexity result: \textbf{state reachability for mDSAs-with-outputs is PSPACE-complete} \cite[Theorem 1]{Keerthan2025netys}.

Finally, we grounded this theoretical work in a practical application by using mDSAs-with-outputs to provide the first formal operational semantics for \textbf{Expressive Decision Tables (EDT)}, a tabular notation used in industry for specifying software requirements \cite{DBLP:conf/date/VenkateshSKA14, DBLP:conf/icst/AgrawalVSZV20}. We developed a translation from the core components of the EDT notation into an mDSA-with-outputs, thereby making EDT specifications amenable to formal analysis \cite[Section 5.1]{Keerthan2025netys}. Test case generation for an EDT row reduces to the state reachability problem in the corresponding mDSA. We implemented a prototype tool based on this translation, demonstrating its ability to automatically generate test cases for intricate, concurrent specifications that would be challenging for randomized or heuristic-based methods \cite[Section 5.2]{Keerthan2025netys}.

\subsection*{Limitations and Future Work}

While this thesis establishes a solid foundation for suffix-reading automata, it also indicates the boundaries of current work and opens several promising avenues for future research.

The NP-completeness of DSA minimization and the PSPACE-completeness of mDSA reachability are significant theoretical hurdles. Our work justifies the use of heuristics, but the development of sophisticated approximation algorithms with provable performance guarantees is an important next step. It would also be valuable to identify broader classes of languages or automata, beyond sDSAs, for which minimization is tractable.

The operational semantics of mDSAs, while precise, are more complex than those of classical automata. This trade-off between expressive convenience and semantic simplicity warrants further investigation, including studies to assess the "readability" and practical usability of the mDSA model for engineers. The PSPACE-hardness of the reachability problem also indicates a potential benefit in exploring techniques from symbolic reachability analysis.

Looking forward, this work suggests several exciting research directions:

\begin{itemize}
    \item \textbf{Automata Learning:} A compelling direction is to develop learning algorithms, in the spirit of Angluin’s L*, to automatically infer DSA or mDSA models from system observations. Such a technique would enable the modeling of black-box systems, facilitating their analysis and verification without requiring manual specification.
    
    \item \textbf{Real-Time and Probabilistic Extensions:} Many real-world systems have real-time constraints. Extending the mDSA model with clocks and timing constraints, as hinted at by the original context of EDTs \cite{DBLP:conf/date/VenkateshSKA14}, would vastly increase its applicability to cyber-physical and embedded systems.
    
    \item \textbf{Hybrid Models:} As DSAs tackle pattern-length complexity and symbolic automata handle alphabet-size complexity, a hybrid model combining both paradigms is a natural and powerful extension. A "symbolic DSA" could use predicates on characters within its suffix-based word labels, offering a unified solution to two orthogonal sources of state explosion.
    
    \item \textbf{Enhanced Tooling and Scalable Analysis:} The prototype mDSA tool demonstrates feasibility \cite{mDSAcode}, but scalable analysis for industrial-sized problems will require more advanced techniques. Exploring symbolic model checking, abstraction-refinement, and other static analysis methods to tackle the PSPACE-hard reachability problem is a critical avenue for future practical impact. Furthermore, investigating closure properties (e.g., union, intersection) directly on the DSA model could lead to more efficient composition and analysis algorithms \cite[Section 9]{Keerthan2024journal}.
\end{itemize}

\subsection*{Concluding Remarks}

The journey from the abstract theory of computation to the concrete practice of software engineering is fraught with challenges of scale and complexity. This thesis attempts to bridge that divide by proposing a new automaton model designed with the structure of modern software specifications in mind. The suffix-reading paradigm moves away from the low-level, letter-by-letter view of computation and toward a higher-level, pattern-centric perspective that aligns more closely with how developers and system architects reason about system behaviour.

By establishing the theoretical properties of DSAs, uncovering the complexities of their minimization, extending them to handle the concurrency inherent in modern systems, and applying them to a practical industrial notation, this work offers a complete, end-to-end research narrative. It demonstrates that the pursuit of more succinct and intuitive formal models is not merely an academic exercise but a vital step toward building more reliable and robust software systems. The theory and tools for suffix-reading automata presented here can hopefully provide a new lens through which to view regular languages, and enable a new instrument in the toolkit of the verification scientist and the software engineer.
