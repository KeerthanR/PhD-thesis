\chapter{Multiport DSAs with outputs}
\label{sec:multiport-outputs}

The previous chapter extended the suffix-reading paradigm to handle concurrent \emph{inputs} via the Multi-port DSA model. However, this represents only half the behavior of a typical reactive system, which must not only process inputs but also \emph{produce outputs} in response. This chapter, based on the work presented in~\cite{Keerthan2025netys}, introduces this final, critical feature, transforming our automaton from a passive recognizer into an active computational model.

A key motivation for this extension is the need to model the powerful feedback loops present in many system specifications. An output generated by one transition can be immediately appended to the system's history, thereby becoming part of the input context for the very next transition. %We see this in practical requirements, such as a car alarm system where an `Alarm: On' output must be instantly available as an input condition for subsequent rules. 
Attempting to model this dynamic by encoding output values into the finite state control would lead to a combinatorial explosion in the number of states. A more direct and scalable approach is to incorporate outputs directly into the transition mechanism.

To this end, this chapter formally defines `mDSA-with-outputs'. We will extend the transition syntax to include an output component and enhance the semantics to allow for `epsilon-transitions'; actions that can be triggered by the current history without consuming new external input, enabling the automaton to evolve based on its own generated outputs. We will show that this small extension has profound consequences, unlocking a large degree of computational power.

The chapter will proceed as follows. First, we will present the formal syntax and operational semantics for the mDSA-with-outputs. Second, we will analyze its computational complexity, proving that the state reachability problem becomes PSPACE-complete~\cite{Keerthan2025netys}. Finally, we will apply this fully-featured model to provide the first formal operational semantics for the industrial `Expressive Decision Table (EDT)' notation~\cite{DBLP:conf/date/VenkateshSKA14}, demonstrating the direct practical relevance of our theoretical investigation.

%marker




In Section~\ref{sec:multiport}, we have seen multi-port DSAs which process inputs across several ports and match transitions. In many situations, requirements also talk about outputting values to certain ports when transitions match. Here is an example of some requirements of a \emph{Car Alarm module}, adapted from~\cite{DBLP:conf/enase/VenkateshSZA15a}. 
\begin{enumerate}
\item If the most recent values on \emph{Ignition} ($I$) and \emph{Alarm} ($A$) are \texttt{Off}, and the last two values on the Panic Switch ($P$) are \texttt{Press;Press}, then the value \texttt{On} is output on the port \emph{Alarm}.

\item If the last three values on the Panic Switch are \texttt{Release;Release;Release}, and the Alarm is \texttt{On}, then output \texttt{False} on \emph{Flash} ($F$)
and \emph{Alarm}.

\item If last value on \emph{Ignition} is \texttt{On}, then \texttt{False} is output on \emph{Flash} and \texttt{Off} is output on \emph{Alarm}.
\end{enumerate}

The first requirement checks for $I:\mathtt{Off} \parallel A:\mathtt{Off} \parallel P:\mathtt{Press;Press}$ and immediately writes $A: \mathtt{On}$. The check-and-update is a fully atomic operation. One way to model this requirement as an mDSA would be to absorb port $A$ as part of the state: that is the state of the mDSA is defined using values of such ports that are used both for inputs and outputs. However, this would lead to an exponential blowup in the number of states when there are multiple such ports that are both read and written on transitions. To succinctly capture requirements with outputs, we allow both reads and writes on all ports and define \emph{mDSAs with outputs}. Later, in Section~\ref{sec:edt} we will use these mDSAs-with-outputs to give a semantics for the industry notation Expressive Decision Tables (EDTs).

\section{mDSA-with-outputs: formal syntax and semantics}
\label{sec:mdsao-synt}
The syntax of mDSA-with-outputs is almost the same as that of mDSAs. The only difference is in the syntax of transitions.  As before, there is a multiport alphabet $\Sigma = \langle \Sigma_1, \dots, \Sigma_k \rangle$. An mDSA-with-outputs $\Bb$ is a tuple $(Q, \Sigma, q_0, \delta)$ where $Q$ is a finite set of states, $q_0$ is the initial state and $\delta$ is a finite set of transitions. We do not view these automata as language acceptors, and so we do not specifically define accept states. We will instead discuss  state reachability. 

\paragraph*{Transitions.} A transition now looks like:
\begin{align*}
q \xra[~~O_1: b_1 ~\parallel~ O_2: b_2 ~\parallel~ \cdots ~\parallel~ O_m: b_m~~]{I_1: u_1 ~\parallel~ I_2: u_2 ~\parallel~ \cdots ~\parallel~ I_\ell: u_\ell} q'
\end{align*}
where $q, q'$ are states; each $u_j$ is a word in the port alphabet of $I_j$; and each $b_j$ is a letter in the port alphabet of $O_j$. We remark that $\{I_1, \dots, I_k\} \cap \{O_1, \dots, O_m\}$ may be non-empty. In other words, some of the ports may appear both as input and output in a transition.  

\paragraph*{Semantics.} Configurations of $\Bb$ are the same as before, given by $(q, w, \theta)$ with $q$ a state, $w$ the word seen so far and $\theta$ a position of the tape head. The semantics is a transition system $\Ss^\Bb = (S, s_0, \xra{})$ where $S$ is the set of configurations, with $s_0$ being the initial configuration $(q_0, \epsilon, 0)$. Let $\rho = (q, (I_1: u_1 \parallel \cdots I_\ell:u_\ell), (O_1: b_1 \parallel \cdots \parallel O_m: b_m), q')$. There are three kinds of transitions in $\Ss^\Bb$:
\begin{itemize}
\item \emph{$\epsilon$-transitions.} $(q, w, \theta) \xra[\rho]{~~\epsilon~~} (q', wb_1 b_2 \dots b_m, |w|)$ if the input condition ($I_1:u_1 \parallel \cdots \parallel I_\ell:u_\ell$) matches the tape configuration $(w, \theta)$; in that case move the tape head to the end of $w$ and write all the outputs to the right of $w$ (order of writing does not matter).
\item \emph{transitions on input letters.} if no outgoing transition from $q$ has a label that  matches the current tape configuration $(w, \theta)$, then there is no $\epsilon$ transition out of $(q, w, \theta)$ and the mDSA-with-outputs listens to further input letters: 
\begin{itemize}
\item $(q, w, \theta) \xra[\rho]{~~a~~} (q', wab_1 b_2 \dots b_m, |wa|)$ if $I_1:u_1 \parallel \cdots \parallel I_\ell:u_\ell$ matches $(wa, \theta)$; then, move the tape head to the end of $wa$ and write the outputs after that,
\item $(q, w, \theta) \xra{~~a~~} (q, wa, \theta)$ if no transition out of $q$ matches $(wa, \theta)$.
\end{itemize}
\end{itemize} 
Notice that the transitions on input letters have the same matching semantics as in an mDSA, except now they also write all the outputs to the end of the word. The main change is the presence of $\epsilon$-transitions. Since we write outputs after matching a transition, on reaching a new state $q'$ there could already be transitions out of $q'$ that match the current tape. Previously, in mDSA, this would not happen, since the tape head would be at the end of the word, and at least one port should see a fully fresh match. 

Surprisingly, this ability to produce outputs which can in turn be consumed by input conditions, creates complex behaviours.  We illustrate this additional difficulty by presenting an mDSA-with-outputs that can succinctly encode an $N$-bit counter.

\subsubsection*{$N$-bit counter.} We wish to implement addition of an $N$-bit counter using an mDSA-with-outputs that has $3$ states $\{q^{init}, q_0, f\}$, $N+1$ ports and $\mathcal{O}(N)$ transitions. Suppose $b_{N-1} b_{N-2} \dots b_1 b_0$ are the $N$ bits, with $b_{N-1}$ the most significant bit and $b_0$ the least significant bit. Addition can be implemented using $N$ rules: for $j \in \{0, \dots, N-1\}$
\begin{itemize}
\item if $b_j = 0$ and $b_{j-1} = b_{j-2} = \cdots = b_0 = 1$, then change $b_j:= 1$ and $b_{j-1} = b_{j-2} = \cdots = b_0 := 0$
\end{itemize}
Starting from $0$ for all bits, there will be exactly one rule that will be applicable each time. Applying the relevant rule each time will lead to $b_{N-1} = b_{N-2} = \cdots = b_0 = 1$ in $2^N - 1$ steps.

To model this counter using an mDSA-with-outputs, we can use $N$ ports $b_{N-1}, b_{N-2}, \dots, b_0$ each having two values $\{0, 1\}$. From the initial state $q^{init}$, we can first read a dummy letter (in a fresh port), write $0$ to all ports $b_{N-1}, \dots, b_0$, and move to state $q_0$. From $q_{0}$ to $q_{0}$, there is a transition for each $j \in \{0, \dots, N-1\}$ in the following form: 
\begin{align*}
q_0 \quad \xra[~~b_j:1 ~\parallel~ b_{j-1}:0 ~\parallel~ \cdots ~\parallel~ b_0: 0~~]{ b_j:0 ~\parallel~ b_{j-1}:1 ~\parallel~ \cdots ~\parallel~ b_0: 1} \quad q_0
\end{align*}
These transitions start a sequence of $2^N -1$ $\epsilon$ transitions which finally result in all ports $b_{N-1}$ to $b_0$ being $1$. To mark the end of the computation, we add an extra transition from $q_0$ that checks if $b_{N-1}:1 \parallel b_{N-1}:1 \parallel \cdots \parallel b_0:1$ and moves to $f$. Notice that the length of the tape when the automaton reaches $f$ is exponential in the size of the input automaton. Therefore, the witness for reachability is exponential. We have crucially used the ability to have ports that can be used both as inputs and outputs. We will now pin down the complexity of the reachability problem in mDSA-with-outputs. 

\subsection{Complexity of state reachability}

We now look at the state reachability problem: given an mDSA-with-outputs $\Bb$ and a state $q$, does there exist a word that reaches $q$? Without outputs, this problem is simply a graph reachability problem, like in a DFA or a DSA. The presence of outputs makes this problem harder, as seen in the $N$-bit counter.








\begin{theorem}\label{thm:complexity}
Emptiness for mDSA with outputs is PSPACE-complete.
\end{theorem}
\begin{proof}
    
    \emph{$\PSPACE$ upper bound.} Let $\Bb$ be an mDSA-with-outputs. Consider the transition system $\Ss^\Bb$ describing the semantics of $\Bb$. Each node in the transition system is of the form $(q, w, \theta)$ where $w$ can become arbitrarily long. Therefore, the transition system, viewed as it is, is infinite. Suppose $M$ is the maximum length among all words used in the transition labels of $\Aa$. This is the maximum length of a suffix that will be checked for in a transition. To detect whether $u_1 \parallel u_2 \parallel \cdots \parallel u_k$ matches a configuration $(q, w, \theta)$, it is sufficient to maintain the last $M$ letters seen in each port. We now explain how this can be implemented.
    
    Assume that in configuration $(q, w, \theta)$, every projection $\proj{i}(w)$ of the word $w$ has at most $M$ letters. We apply the criteria for verifying if $(u_1 \parallel u_2 \parallel \cdots \parallel u_k)$ matches the tape configuration $(w, \theta)$ as in Definition~\ref{def:match}. Now, when we append $a \in \Sigma_i$ to the end of $w$: if $wa$ contains $M+1$ letters in port $i$, that is $|\proj{i}(wa)| = M+1$, then let $w'$ be the word obtained by deleting from $wa$ the first occurrence of a letter in $\Sigma_i$. Let $b$ be this letter. If $b$ appeared at a position strictly greater than $\theta$ in $wa$, then we do not need to change the tape head ($\theta' = \theta$); otherwise, $b$ appears on or before $\theta$, and we reduce tape position by $1$ ($\theta' = \theta - 1$). This gives a new tape configuration $(w', \theta')$. Transitions point to the new truncated configuration. Call the new truncated transition system as $\Ssf^\Bb$.
    
    
    This bounds the tape length to $M \times k$, where $k$ is the total number of ports. So, the total size of the truncated transition system is exponential in the size of the input. To verify emptiness, it is sufficient to guess a path in this transition system. Since each node requires polynomial space, and the length of the witness is bounded by an exponential in the size of the input, we deduce a $\PSPACE$ upper bound for the emptiness problem, following standard complexity theoretic arguments. 

    \emph{$\PSPACE$-hardness.} For the hardness, we give a reduction from this problem: given DFAs $D_1, D_2, \dots, D_n$ over a common alphabet $\Sigma$, the DFA-intersection-emptiness asks if there exists a word in the language of all the $n$ DFAs. This is known to be $\PSPACE$-complete~\cite{10.1109/SFCS.1977.16}. Let $D_j = (Q_j, q^{init}_j, \delta_j, F_j)$ be the description of DFA $D_j$. The mDSA-with-outputs $\Bb^D$ that we will construct makes use of $n$ ports to store the state reached by each of the DFAs.

    We will have one input port $I$ with $\Sigma$ as alphabet, and $n$ ports $S_j$ (for $j \in \{1, \dots, n\}$), with $\Sigma_j = Q_j$ being the states of DFA $D_j$. We add a special port $L$ with alphabet $\$$ that will be used for book-keeping. Let $s^{init}$ be the initial state of $\Bb^D$. There is an initial transition that reads the special character $\$$ and writes the initial state of each DFA to the respective ports, and moves to $s_0$:
    \begin{align*}
    s^{init}~~ \xrightarrow[~S_1: q^{init}_1 ~\parallel~ S_2: q^{init}_2 ~\parallel~ \cdots ~\parallel~ S_n: q^{init}_n~]{L: \$} ~~s_0
    \end{align*}
    From $s_0$ we have a gadget that reads the next input and then sequentially updates the states of each DFA by writing the new states in the respective ports. 
    \begin{itemize}
        \item the process starts with a transition $s_0~\xra[L:\$]{I:a} s^a_1$; 
        \item there are states $s^a_{j}$ for all $j \in \{1, \dots, n\}$, and for all $a \in \Sigma$;
        \item for every transition $(q_j, a, q'_j)$ in $D_j$ we have: $s^a_j \xra[~L:\$~\parallel~S_j: q'_j~]{L:\$ ~\parallel~ S_j: q_j~} s^a_{j+1}$, with $s^a_{n+1} := s_0$.
    \end{itemize}
    When an $a$ is read at $s_0$, the automaton moves to $s^a_1$ and the tape head moves to the position of $a$. Since the same transition also writes a $\$$ to $L$, there will be an outgoing transition from $s^a_1$ that matches: this transition would be the one corresponding to the current state of $D_1$. Then, the automaton goes to $s^a_2$, and the process continues until the automaton comes back to $s_0$, giving rise to a sequence of $n$ $\epsilon$-transitions from $s^a_1$ back to $s_0$. 

    This is the basic construction that simulates the $n$ DFAs using an mDSA-with-outputs. To detect acceptance, we can add special ports $B_1, B_2, \dots, B_n$. Whenever we reach an accepting state in $Q_j$ we write $1$ to this port, and when we reach a non-accepting state, we write $0$. Add a transition $B_1 = 1 \parallel B_2 = 1 \parallel \cdots \parallel B_n = 1$ from $s_0$ to a special state $f$. The intersection of $D_1, \dots, D_n$ is empty iff $f$ is reachable.

    For every letter $a$ and every port $j$ there is a state $s^a_j$. There are transitions $s^a_j$ to $s^a_{j+1}$ for each every transition in $D_j$. Total number of states is $(|\Sigma| \cdot n) + 2$, and the total number of transitions is proportional to $\sum_j \delta_j$.  Therefore, the overall construction is polynomial-time.


\end{proof}







\section{Expressive decision tables}
\label{sec:edt}
Expressive Decision Tables (EDTs)~\cite{DBLP:conf/date/VenkateshSKA14} are a tabular
notation for specifying software requirements and have been used in various
industrial settings~\cite{DBLP:conf/enase/VenkateshSZA15a,DBLP:conf/icst/AgrawalVSZV20}.  An EDT specification consists
of tables where columns specify input, output and input/output (I/O) ports, and rows specify the relationship between input and output
values on these ports. Each port is associated with an alphabet and each cell in the table consists of a string of letters from this alphabet.% with discrete
The original work on EDTs contained timing constraints in the cells and interpreted the EDT over a notion of discrete-time. In this paper we consider EDT without time. A cell in  an EDT table
is said to match when the string given in that cell is a suffix of the values seen for the
input port corresponding to that cell's column. A row of an EDT matches when
all the cells corresponding to that row match and one cell matches on the last
input.  Table~\ref{tab:edt-alarm} gives the EDT specification of the Car Alarm module described in the beginning of Section~\ref{sec:multiport-outputs}. We write $F$ for \texttt{Off} and \texttt{False}, $N$ for \texttt{On}, $P$ for \texttt{Press} and $R$ for \texttt{Release}.

\newcolumntype{A}{>{\centering}p{1cm}}
\begin{table}[h!]
  \centering \def\arraystretch{1.5}
  \caption{EDT for an Alarm module}
  \label{tab:edt-alarm}
	\begin{tabular}{|A|A|A|A||A|c|}
    \hline
    s.no & in  I & in  P & in A & out  A & out  F \\
	 \hline
    1 & F & P;P & F& N & \\
    \hline
    2 & & R;R;R & N & F & F \\
    \hline
    3 & N & & & F & F \\
    \hline
  \end{tabular}
  
\end{table}
In the example EDT the input ports are prefixed with 
\emph{in} and output ports are prefixed with \emph{out}. Input/Output ports are prefixed with both \emph{in} and \emph{out}. These are the ports that appear on both sides of the EDT, as inputs as well as outputs. 

A \emph{test case} for a requirement is a sequence of values  that match the
EDT row corresponding to that requirement. The use of EDTs and test case generation
algorithms from EDT specifications have been widely studied.
~\cite{DBLP:conf/enase/VenkateshSZA15a,DBLP:conf/icst/AgrawalVSZV20}. However, the notation lacks a rigorous
formal semantics, except for a brief description of key elements of formal
semantics in~\cite{DBLP:conf/date/VenkateshSKA14}. Hence, none of the test case algorithms use
formal techniques like model checking and instead rely on random generation
using heuristics. These algorithms, therefore, cannot prove that an EDT row
cannot be matched and also find it hard to match certain rows. We overcome both
these limitations by providing a formal semantics for EDTs (without timing)
through a translation to mDSA-with-outputs.


\subsection{Translating EDT to mDSA-with-outputs}

An EDT with $C$ columns and $R$ rows is translated to an mDSA, with one
state $q_0$ and an alphabet $\Sigma = \langle \Sigma_1 \cdots \Sigma_{|C|} \rangle$.
Each $\Sigma_i$ corresponds to the port of column $i$ and the
letters of the alphabet correspond to the values that the signal can take,
prefixed by $\langle Portname: \rangle$. 
Thus if the Port name of the first
column is $A$ and its alphabet is ${ a_1, a_2, \cdots, a_k}$ then the
corresponding alphabet $\Sigma_1 = {A:a_1, A:a_2 \cdots A:a_k}$. 
Each EDT row is translated to an mDSA as follows:
\begin{itemize}
\item The mDSA has exactly one state $q_0$

\item
There is a transition corresponding to each row with $q_0$ as both the source and target state. 
\item
The label of each transition consists of all the strings in the cells of the input columns of the row combined using the $\parallel$ operator.
\item 
The output of the transitions are the strings in the cell corresponding to the output columns, combined using the $\parallel$ operator.
\end{itemize}

The mDSA in Figure~\ref{fig:state-diagram} is an mDSA specification corresponding the EDT given in Table~\ref{tab:edt-alarm}

\begin{figure}
    \centering
\begin{tikzpicture}[
    > = stealth,
    shorten > = 1pt,
    auto,
    node distance = 3cm,
    semithick
]

% Setup the styles for the states
\tikzstyle{accepting}=[double, draw=black, circle, minimum size=1cm]
\tikzstyle{state}=[draw=black, circle, minimum size=1cm]

% Draw the state
\node[state, initial, accepting] (q0) {$q_0$};

% Draw the transition (self-loop)
\draw (q0) edge[loop above] node{$I:F$$\|$$P:P;P:P$$\|$$A:F$/$A:N$} (q0);
\draw (q0) edge[loop right] node{$P:R;P:R;P:R$$\|$$A:N$/$A:F$$\|$$F:F$} (q0);
\draw (q0) edge[loop below] node{$I:N$/$A:F$$\|$$F:F$} (q0);

\end{tikzpicture}
\caption{mDSA of the Alarm EDT}
    \label{fig:state-diagram}
\end{figure}

To generate a test for a certain row $r$, we can first add a special state $q_r$, and make the transition corresponding to this row point to $q_r$ instead of $q_0$. A test  for $r$ then reduces to a witness for the reachability of $q_r$. 





\subsection{Experiments}
\label{sec:experiments}
We have implemented a prototype test generator for EDTs using the translation of EDTs to mDSA-with-outputs \cite{mDSAcode}. In our implementation, we translate the given EDT $\Tt$ into an mDSA-with-outputs $\Bb^\Tt$ and simulate the semantics of $\Bb^\Tt$ using the finite transition system $\Ssf^{\Bb^\Tt}$ described in the proof of Theorem~\ref{thm:complexity}.

First we look at a couple of small EDTs. Suppose we want a testcase for Row 1 in Table~\ref{tab:edt-alarm}. Encoding this in our tool gives a testcase ($P; P$) for Row 1, when default values for $I$ and $A$ are set to $F$.
Next we look at Table~\ref{tab:wiper}, a partial representation of a wiper module in a car. The tool finds a testcase (park;notpark) for Row 2.

\begin{table}[h!]
  \centering \def\arraystretch{1}
  \caption{EDT for a Wiper module}
  \label{tab:wiper}
  \begin{tabular}{|c|c|c|c|c||c|c|}
    \hline
    sno & \specialcell{in \\ ignition} &
                                         \specialcell{in \\ wiperswitch} & 
                                                                       \specialcell{in 
    \\ parksensor} & \specialcell{in \\ error} & \specialcell{out \\ wipercmd} & 
                                             \specialcell{out \\ error} \\
    \hline 
    1 & on & on & 
    & false & wipe &
    \\
    \hline

    2 & & & (park;notpark) & & dontwipe & true \\
    \hline
  \end{tabular}
  
\end{table}


We now present an EDT for which our tool can solve the test generation problem, whereas randomized techniques will have low success probability. 
The EDT is a slight variation of the $N$ bit counter presented in Section~\ref{sec:mdsao-synt}. We depict a part of the EDT for three bits in
Table \ref{tab:binary}. 
In addition we add a row to check for all $t_i = 1$ , and also have an extra letter in the port $T$. Therefore there is exactly one sequence that makes all the $t_i$ equal to $1$. Randomized techniques have a low probability of generating such a test case. 
Our prototype implementation generates a test case for $N=5$. 


\begin{table}
  \centering
  \renewcommand{\arraystretch}{1} 
  \caption{Implementing a binary counter for $3$ bits}
  \label{tab:binary}
  \begin{tabular}{|c|c|c|c|c||c|c|c|c|}
    \hline
    $T$ & $t_2$ & $t_1$ &$t_0$ & $S_T$ & $t_2$ & $t_1$ & $t_0$ & $S_T$                                                             
    \\
    \hline
     \checkmark & & & & & & & & $+$  \\
         
    \hline
     & & & $0$ & $+$ & & & $1$ & $-$  \\

    \hline
   & & $0$ & $1$ & $+$ & & $1$ & $0$ & $-$ \\

    \hline
   & $0$ & $1$ & $1$ & $+$ & $1$ & $0$ & $0$ & $-$ \\

    \hline
  \end{tabular}
\end{table}

Our goal with the experiments was not to present a scalable tool for EDT test generation. We aimed to create an open source simulator for mDSA-with-outputs, which we have applied on EDT test case generation. As future work, we plan to investigate scalable algorithms for reachability in mDSA-with-outputs.

%marker


\vspace{.25cm}


This chapter presented the final evolution of the suffix-reading automaton model: the `mDSA-with-outputs'. By incorporating the ability for transitions to atomically produce outputs that are written back to the history tape, we created a model capable of specifying complex, reactive, and concurrent systems, as shown in~\cite{Keerthan2025netys}. The central new dynamic introduced was the feedback loop enabled by `epsilon-transitions', which allow the automaton to execute a cascade of actions based on its own generated outputs without requiring external stimuli.

The impact of this feature was captured in the chapter's main theoretical result: the proof that state reachability for mDSAs-with-outputs is PSPACE-complete~\cite{Keerthan2025netys}. The N-bit counter example demonstrated vividly how the history tape can be used as a working memory of exponential size, formally capturing the computational power unlocked by this input-output mechanism.

This entire development arc embodies the subtitle of this dissertation, "Putting Practice into Theory (and back)." The practical need to provide a formal foundation for the industrial `Expressive Decision Table (EDT)' notation~\cite{DBLP:conf/date/VenkateshSKA14} motivated the theoretical extension from DSA to mDSAs-with-outputs. The formal analysis of this new theoretical model, in turn, revealed a deep and fundamental complexity result. This theoretical discovery then feeds back to practice, providing a rigorous explanation for the inherent difficulty of test generation for EDT-like specifications and informing the design of future analysis tools.

With the introduction and analysis of the mDSA-with-outputs, our development of the suffix-reading automata family is now complete. We have journeyed from a foundational model for sequential patterns to a powerful formalism for concurrent, reactive systems. The final chapter will now step back to summarize the overarching contributions and implications of this entire body of work, and to outline promising avenues for future research.